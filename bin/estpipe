#!/usr/bin/env perl

=head1 NAME

estpipe - process baboon ESTs for dbEST submission

=head1 SYNOPSIS

B<estpipe> [B<--version> | [B<-?|-h|--help>] | [B<-d|--debug>] |
  [B<[-i|--infile> fasta_sequencefile] |
  [B<[-m|--masked> idfile] |
  [B<[-o|--outdir> dirname] |
  [B<[-c|--config conf.xml >]
  fasta_sequencefile [ fasta_sequencefile ... ]*


=head1 DESCRIPTION

This program implements the following pseudocode:

 for each EST sequence s1
    scan s1 for linker
    if hit,
        if hit in the beginning of s1
            remove the hit and everything up to it s1 -> s2
        if at the end of s1
            remove the hit and rest of the s1 -> s2
    rescan for the second linker
    dust the s2 -> s3
    BLAST the dusted seq s3 against all human proteins
    if hit above threshold
        record the best hit: gene name, database(swissprot|trembl):accession
    write s2 out in dbEST format
    write log


=head1 RUNNING

../estpipe -m detect_repeats_log_9084 BABEVCEREB-C-01-1-7KB.fasta &


=head1 VERSION HISTORY

  0.0.0, 02 Nov 2007, start of the project, code based on ppp/epiq
  0.1.0, 02 Oct 2007, formats seq into dbEST
  0.2.0, 22 Oct 2007, output correctly structured
  0.3.0, 11 Nov 2008, skip seqs based on ID list (generated by repeatmasker), -m

=head1 TODO

-

=head1 BUGS

Please report bugs to the author.

=head1 LICENSE

You may distribute this program under the same terms as perl itself.

=head1 AUTHOR

Heikki Lehvaslaiho, heikki a sanbi ac za

=head1 URL

You can get the latest version of this program at
http://www.sanbi.ac.za/

=head1 APPENDIX

The rest of the documentation details each of the subroutines this
program is composed of.

=cut

use 5.8.0;  # recent perl to avoid surprises

use Bio::SeqIO 1.006;
use Bio::SearchIO;
use Bio::Tools::Run::StandAloneBlast;
#use Bio::Tools::Run::Mdust2;

use Getopt::Long;
use Data::Dumper;
use Text::Wrap;
use XML::Simple;

use strict;
use warnings;




#our (#$estid,   # the read id (the number that follows the > sign) 
#     $cloneid, # the clone_insert_id 
#     $plateid, # sequencer_plate_barcode
#     $row,     # Sequencer_plate_well_coordinates
#     $column,  # sequencer_plate_well_coordinates
#     $homolog,   # the highest scoring hit from BLAST in form: Similar to H. sapiens Gene_name)
##     $seq      # sequence
#    );

# Debuging variables             values for production mode
my $DEBUG = 0;                   # 0
my $SKIP_RAW = 0;                # 0

my $OUTDIR = '';    # outfile
my $SEQNO = 0;       # sequence counter
#my $BATCH_SIZE = 10; # how many sequences to wait before writing

#my $RESULT; # hash reference for all results

use constant PROGRAMME_NAME => 'estpipe';
use constant VERSION => '0.3.0';

my $TMPDIR ="/tmp";  # where we store the temp seq file
my $SEQFILE = "$TMPDIR/query.fa$$";
my $LINKEREXO = "$TMPDIR/linker.exo$$";
my $BLASTOUT = "$TMPDIR/blast_seq_out$$";
my $BLASTMITOOUT = "$TMPDIR/blastmito_seq_out$$";


# interpretation of nonstandard sequence characters in BLAST protein output
#my $GAP          =   '-';
#my $STOP         =   '*';
#my $FRAMESHIFT   =   '/';
#my $UNKNOWN      =   '\\';  # find out what this does

my $NOLOG;   # no log output

my $CONFIG;
my $SILENT;
my $SKIPID;

GetOptions(
           'v|version'    => sub{ print PROGRAMME_NAME, ", version ", VERSION, "\n";
                                  exit(1); },
           'd|debug'      => \$DEBUG,
           'c|config:s'   => \$CONFIG,
           'l|nolog'      => \$NOLOG,
	   'm|masked:s'   => \$SKIPID,
	   'o|outfile:s'  => \$OUTDIR,
           's|silent'     => \$SILENT,
           'h|help|?'     => sub {exec('perldoc',$0); exit 0;}
           );

if ($CONFIG) {
    $CONFIG = XMLin($CONFIG); # XML::Simple::XMLin()
} else {
    $CONFIG = XMLin(); # XML::Simple::XMLin()
}

print Dumper $CONFIG if $DEBUG;
die "ERROR: ". PROGRAMME_NAME. ".xml is not in the same version as program file\n"
    if $CONFIG->{version} ne VERSION;

#our $BLASTDB = $CONFIG->{blastdb} || $BLASTDB || '.';
#my $BLASTDIR = $CONFIG->{blastdir} || $BLASTDIR || '';

my $LOGFILE = "$OUTDIR/estpipe.log";
open LOG, ">", $LOGFILE  or die "Can't open file $LOGFILE: $!";
print LOG "Date: ". `date` unless $NOLOG;

my $ESTSEQFILE = ">$OUTDIR/est_seqs";
my $DBESTFILE  = "$OUTDIR/dbest";
open DBEST, ">", $DBESTFILE  or die "Can't open file $DBESTFILE: $!";




# create the linker fasta file once for all queries
#my $linker_fasta = ">linker\n". $CONFIG->{contamination}->{query}->{content}. "\n";
my $LINKER = $TMPDIR. "/linker.fa$$";
`echo ">linker" > $LINKER; echo $CONFIG->{contamination}->{query}->{content} >> $LINKER`;


=head2 clean_linker

  Arg [1]    : sequence, Bio::PrimarySeqI object
  Example    : $seq = clean_linker($seq);
  Description: Detects contaminating linker DNA and removes it
               and outlying sequence
  Returns    : sequence object that might have been altered
  Exceptions : -
  Caller     : main()

=cut

sub clean_linker ($$) {
    my $config = shift;
    my $seq = shift;


    my $tmp = Bio::SeqIO->new(-file => ">$SEQFILE",
                              -format => 'Fasta');
    $tmp->write_seq($seq);

    print Dumper $config if $DEBUG;

    my $program = $config->{program};
    my $options = $config->{options};

#    die "No such file: [$database]" unless -e $database;

    my $cmd = "$program $LINKER $SEQFILE $options";
    print $cmd if $DEBUG;
    `$cmd > $LINKEREXO`;

    my $searchio = Bio::SearchIO->new(-file => $LINKEREXO,
                                      -format => 'exonerate');

    my $lhit;
  BLAST: {
    while( my $result = $searchio->next_result ) {
        print $result->query_name, "\n" if $DEBUG;
        while( my $hit = $result->next_hit ) {
            $hit->verbose(-1);
            # process the Bio::Search::Hit::HitI object
            while( my $hsp = $hit->next_hsp ) {
                # process the Bio::Search::HSP::HSPI object
                $lhit->{start} = $hsp->start('hit');
                $lhit->{end} = $hsp->end('hit');
                print Dumper $lhit if $DEBUG;

                last BLAST;
            }
        }
    }
    }
    unless (exists $lhit->{start}) {
        print LOG $seq->id, ": ". "no linker\n" unless $NOLOG;
        return $seq;
    }

    my $lhit_string = $lhit->{start}. '-'. $lhit->{end};

    my $subseq;
    if ( $lhit->{start} < 20 ) {
        $subseq = $seq->trunc($lhit->{end}+1, $seq->length);
        $subseq->desc($subseq->desc. ' /linker=5prime');
        print LOG $seq->id, ": ". "linker removed from 5prime [$lhit_string]\n"
            unless $NOLOG;

        print Dumper $subseq if $DEBUG;
    }
    elsif ( $lhit->{end} >  ($seq->length - 30) ) {
        $subseq = $seq->trunc(1, $lhit->{start}-1);

        $subseq->desc($subseq->desc. ' /linker=3prime');
        print LOG $seq->id, ": ". "linker removed from 3prime [$lhit_string]\n"
            unless $NOLOG;
        print Dumper $subseq if $DEBUG;
    } else {
        print LOG $seq->id, ": ". "linker not near seq ends [$lhit_string] (". 
            $seq->length. ")\n"
            unless $NOLOG;
        print STDERR $seq->id. ": linker not near seq ends (". $seq->length. ")\n";
    }
    return $subseq;
}




=head2 mdust

  Arg [1]    : sequence, Bio::PrimarySeqI object
  Example    : $seq = mdust($seq);
  Description: mask low complexity regions with mdust
  Returns    : a new Bio::PrimarySeq object
  Exceptions : no write permissions to tmp files
  Caller     : main()

This is a low overhead replacement for Bio::Tools::Run::Mdust that has
issues with stability when running over large number of sequneces.

=cut

sub mdust ($) {
    my $seq = shift;

    my $min = "/tmp/mdust.$SEQNO";
    my $out = Bio::SeqIO->new(-file => ">$min",
                              -format => 'Fasta');
    $out->write_seq($seq);
    $out->flush;

    `mdust $min > $min.out`;

    my $in = Bio::SeqIO->new(-file => "$min.out",
                             -format => 'Fasta');
    $seq = $in->next_seq($seq);

    unlink $min;
    unlink "$min.out";

    return $seq;
}



=head2 human_mitochondria

  Arg [1]    : hashref to the mitochondia detection part of the config
  Arg [2]    : sequence, Bio::PrimarySeqI object
  Example    : $res = mitochondira($config);
  Description: Detects closest mitchondrial sequences
  Returns    : boolean, true if sequence has significant mito homology
  Exceptions : blast database does not exist
  Caller     : main()

=cut



sub human_mitochondria ($$) {
    my $config = shift;
    my $seq = shift;


    my $e_value = $config->{cutoff}->{e_value};

    my $database = $config->{database};
    die "No such file: [". $database. "]" unless -e  $database;

    my $res;


    print LOG $seq->id, ": BLASTing against $database\n" unless $NOLOG;

    # set blast parameters
    my $blast_outfile = $BLASTOUT;
    my @params = ( -program => $config->{program},
                   -database => $database,
                   -outfile => $BLASTMITOOUT,
                   # using the default output format
                 );
    push (@params, $1 => $2) while $config->{options} =~ /(-\w+) +(\S+)/g;
    my $factory = Bio::Tools::Run::StandAloneBlast->new(@params);
    $factory->outfile_name($BLASTOUT);

    # Blast a sequence against the database:
    my $report = $factory->blastall($seq);

    #        # read in raw blast output
    #        {
    #            open my $BLAST, '<', $BLASTOUT;
    #            my $raw_result;
    #            while (<$BLAST>) {$raw_result .= $_ }
    #            $res->{raw}->{name} =  'blast';
    #            $res->{raw}->{text} =  $raw_result unless $SKIP_RAW;
    #        }


#
#        use Bio::SearchIO::FastHitEventBuilder;
#        my $searchio = new Bio::SearchIO(-format => $format, -file => $file);
#
#        $searchio->attach_EventHandler(Bio::SearchIO::FastHitEventBuilder->new);
#        while( my $r = $searchio->next_result ) {
#            while( my $h = $r->next_hit ) {
#                # Hits will NOT have HSPs
#                print $h->significance,"\n";
#            }
#        }


    # analyze the output
    while ( my $blast_result = $report->next_result ) {
        while ( my $bphit = $blast_result->next_hit ) {
            $bphit->verbose(-1);
            print $seq->id, ": ", $bphit->significance,"\n" if $DEBUG;
            print LOG $seq->id, ": best mito hit significance: ", $bphit->significance, "\n" unless $NOLOG;

            return 1 if $bphit->significance < $e_value;
            return 0;
        }
    }
}



=head2 human_homolog

  Arg [1]    : hashref to the protein part of the config
  Arg [2]    : sequence, Bio::PrimarySeqI object
  Example    : $res = human_homolog($config);
  Description: Detects closest homolog in human proteins
  Returns    : string
  Exceptions : blast database does not exist
  Caller     : main()

=cut

sub human_homolog ($$) {
    my $config = shift;

    my $seq = shift;

    my $bitscore_limit = $config->{cutoff}->{bit_score};
    my $proteomes;

    foreach my $database (@{$config->{database}}) {
        next if $database eq '-';

        my $res;

        die "No such file: [". $database. "]"
            unless -e  $database;

        print LOG $seq->id, ": BLASTing against $database\n" unless $NOLOG;

        # set blast parameters
        my @params = ( -program => $config->{program},
                       -database => $database,
                       -outfile => $BLASTOUT,
                       # using the default output format
                     );
        push (@params, $1 => $2) while $config->{options} =~ /(-\w+) +(\S+)/g;
        my $factory = Bio::Tools::Run::StandAloneBlast->new(@params);
        $factory->outfile_name($BLASTOUT);

        # Blast a sequence against the database:
        my $report = $factory->blastall($seq);

#        # read in raw blast output
#        {
#            open my $BLAST, '<', $BLASTOUT;
#            my $raw_result;
#            while (<$BLAST>) {$raw_result .= $_ }
#            $res->{raw}->{name} =  'blast';
#            $res->{raw}->{text} =  $raw_result unless $SKIP_RAW;
#        }


        # analyze the output
      BLAST:{
        while ( my $blast_result = $report->next_result ) {
            $res = undef;
            while ( my $bphit = $blast_result->next_hit ) {
                last if $bphit->bits <= $bitscore_limit; ### cut-off
                my $hit;
### test this                print $hit->desctiption;
                $hit->{sid} = $bphit->name;

                while ( my $hsp = $bphit->next_hsp ) {
#                next if $hsp->percent_identity < $identity_limit;  ### cut-off

                    my ($gn, $db) = $hsp->{HIT_DESC} =~ /gn=([^;]*); db=([^ \n]+)/;

                    $hit->{gn} = $gn if $gn;
                    $hit->{db} = $db;
                    $hit->{bitscore} = $bphit->bits;;
                    $hit->{identity} = $hsp->percent_identity;

#                    last;       # taking in only the first HSP, is it always the longest?
                } # each hsp

                # add hit into result

                if (exists $res->{hit} ) {
                    print Dumper $res, $hit if $DEBUG;
                    #next if $hit->{db} eq 'trembl';
                    last BLAST if $hit->{bitscore} <  $res->{hit}->{bitscore};
                    last BLAST if $res->{hit}->{db} eq 'UniProtKB/Swiss-Prot';
                }
                $res->{hit} = $hit if exists $hit->{identity};

#                last;
            } # each hit
        } # analyze blast output
    } # BLAST

	print Dumper $res  if $DEBUG;

        # add results from each proteome


#        push @{$proteomes}, $res;
#        print Dumper $res; ###
#        unlink $blast_outfile unless $DEBUG;

        return unless $res->{hit};
        $res->{hit}->{gn} ||= 'NONAME';
        my $res_string = $res->{hit}->{gn}. " (".  $res->{hit}->{db}. ":". $res->{hit}->{sid}. ")";
#        print LOG $seq->id, ": $res_string\n" unless $NOLOG;


        #Correct way: 
        #UniProtKB/Swiss-Prot:P10275   sprot
        #UniProtKB/TrEMBL:Q5JUN9       trembl

        #$res_string =~ s|sprot|UniProtKB/Swiss-Prot|;
        #$res_string =~ s|trembl|UniProtKB/TrEMBL|;


        return $res_string;

    } # each database



#    return $proteomes;
}





#
##
### main
##
#



my $SKIPIDS;

if ($SKIPID) {

    open my $ID , "<", $SKIPID or die "can not open file $SKIPID";

    # id file
    while (<$ID>) {
	next unless  /^(\d+):/;
	$SKIPIDS->{$1}++;
    }
}

my $file = shift;
die "Usage: estpipe fastafile\n" unless $file;

my $in = Bio::SeqIO->new(-file => $file,
                         -format => 'Fasta');

my $out = Bio::SeqIO->new(-file => $ESTSEQFILE,
                          -format => 'Fasta');


while ( my $seq = $in->next_seq() ) {

    $SEQNO++;
    my $estid = $seq->id;
    print LOG "$estid: ". "#$SEQNO\n" unless $NOLOG;

    if ($SKIPIDS->{$estid}) {
	print LOG "$estid: ". "repeatmasked until less than 64 nt and removed\n"
	unless $NOLOG;
	next;
    }


# not needed for evrogen library
#
#        # remove contaminating linker DNA
#        $seq = clean_linker($CONFIG->{contamination}, $seq);
#        print LOG "$estid: ". "skipped, linker in the middle\n" and next
#            unless $NOLOG or $seq;
#
#        # repeat just in case there is an other copy of linker seq
#        $seq = clean_linker($CONFIG->{contamination}, $seq);
#        print LOG "$estid: ". "skipped, linker in the middle\n" and next
#            unless $NOLOG or $seq;
#

        # dust the sequence for low-complexity regions
    my $seq_dusted = mdust($seq);

    if ($seq->seq eq $seq_dusted->seq) {
	print LOG $seq->id, ": mdust, no change\n" unless $NOLOG;
    } else {
	print LOG $seq->id, ": mdust, sequence dusted\n" unless $NOLOG;
    }

    # unabiguous seq has to be longer than 64 nucleotides

    my $seq2string = $seq_dusted->seq;
    $seq2string =~ s/N//g;
    my ($len) =  length $seq2string;
    print $seq->id, ": ", $seq->length, " -> ", $len, "\n"
        if $len < 64 and $DEBUG;
    if ($len < 64) {
	print LOG "$estid: ".
	"skipped, high complexity seq shorter than 64 nt [$len]\n"
	unless $NOLOG;
	next;
    }

    # write sequence into an other file
    $out->write_seq($seq);



    #human_mitochondrial hits are skipped
    if (human_mitochondria($CONFIG->{mitochondria}, $seq) ) {
	print LOG "$estid: ". "skipped, matches mitochondrial genome\n"
	unless $NOLOG;
	next;
    }



    # run the blast search against every human protein
    my $homolog =  human_homolog($CONFIG->{proteome}, $seq);
    $homolog ||= '';
    unless ($NOLOG) {
	$homolog ?
	( print LOG "$estid: ". "human homolog: $homolog\n" ) :
	( print LOG "$estid: ". "no human homolog found\n" )
    }

    $homolog =  "\nPUT_ID: H. sapiens $homolog" if $homolog;

    # parse the header
    my %descr = map {/\/([^=]+)=(\w+)/; $1 => $2}  split / /,  $seq->description;
    my ($lib)  =  $seq->description =~ /library_name=([^ ]+)/;
    my $cloneid = $descr{clone_insert_id};
    my $plateid = $descr{growth_plate_barcode};

    my $sense = $descr{direction};
    #        print Dumper $sense, $CONFIG->{primer}; exit;
    my $primer = $CONFIG->{primer}->{$sense};

    my $p_end;
    if ($sense eq 'forward') {
	$p_end = "3'";
    } else {
	$p_end = "5'";
    }

    my ( $row, $column) = 
    $descr{sequencer_plate_well_coordinates} =~ /([A-Z]+)(\d+)/;
    my $seqstring = wrap('', '', $seq->seq); # defaults to 75 characters


    my $dbest = "TYPE: EST
STATUS: New
CONT_NAME: Bumgarner R
CITATION:
Evolutionary insights from large scale Papio anubis cDNA sequencing project
LIBRARY: $lib
EST#: $estid
CLONE: $cloneid
SOURCE: Bumgarner Lab, Department of Microbiology, University of Washington
ERROR: 0.0001
PLATE: $plateid
ROW: $row
COLUMN: $column
SEQ_PRIMER: $primer
P_END: $p_end
DNA_TYPE: cDNA
PUBLIC:$homolog
COMMENT:
Institutes contributing to this submission are: University of
Washington (UW), Seattle, USA; South African National Bioinformatics
Institute (SANBI), University of the Western Cape, South Africa and
J. Craig Venter Institute (JCVI), Rockville, USA. Tissue samples were
provided by Southwest Foundation for Biomedical Research (SFBR), San
Antonio, USA.
Additional details are available at ftp://baboon.washington.edu/.
SEQUENCE:
$seqstring
||
";

    print DBEST $dbest;
    print LOG $estid, ": writing dbest format\n" unless $NOLOG;

}



END {
#    unlink $LINKER;
    unlink $SEQFILE;
    unlink $LINKEREXO;
    unlink $BLASTOUT;
    unlink $BLASTMITOOUT;

    if ($SILENT) {
        print `less $LOGFILE`;
        unlink $LOGFILE;
        $ESTSEQFILE =~ s/>//;
        unlink $ESTSEQFILE;
        unlink $DBESTFILE;

    }
    no warnings;
    print LOG "Date: ". `date` unless $NOLOG;

}
